/*
 * serve_client.c
 * 
 * Copyright 2017 Unknown <atuser@Hyperion>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 * 
 * 
 */


#include <serve_client.h>
#include <ip_convert.h>

struct serve_client * get_client_from_host (struct serve_client_manager * manager, char* hostname) {
    struct serve_client * current = manager->clients[0];
    while (current != NULL) {
        if (strcmp(current->hostname, hostname) == 0) {
            break;
        }
        current = current->next;
    }
    
    return current;
}

struct serve_client * get_client_from_ip (struct serve_client_manager * manager, char* ip) {
    char hostname [100];
    ip_to_hostname (ip, hostname);
    return get_client_from_host (manager, hostname);
}

void add_to_manager (struct serve_client_manager * manager, struct serve_client conf) {
    if (manager->used + 1 >= manager->size) {
        manager->clients = realloc (manager->clients, sizeof(struct serve_client*) * (manager->size + 5));
        manager->size += 5;
    }
    manager->clients[manager->used] = &conf;
    if (manager->used == 0) {
        manager->clients[manager->used]->back = NULL;
    }
    else {
        manager->clients[manager->used]->back = manager->clients[manager->used - 1]; // Update current object
        manager->clients[manager->used]->back->next = manager->clients[manager->used]; // Update the previous object
    }
    manager->clients[manager->used]->next = NULL; // Append so always last;
    manager->used++;
}


/* Because a system is just a set of packages
 * All we need here is to setup a make.conf to emerge these packages
 */
void init_serve_client (struct serve_client_manager * manager, struct serve_client conf) {
    char make_conf_buff [1024];
    char _ROOT_ [128];
    sprintf (_ROOT_, "%s/%s/", manager->top_dir, conf.hostname);
    sprintf (make_conf_buff, "# This file has been generated by AutoGentoo\n\
# Do NOT change any settings in this file\n\
# Changes to this file could cause both\n\
# server and client system corruption!\n\
\n\
# System architecture configuration\n\
CFLAGS=\"%s\"\n\
CXXFLAGS=\"%s\"\n\
CHOST=\"%s\"\n\
\n\
# Portage system configuration\n\
SYS_ROOT=\"%s\"\n\
PORTAGE_TMPDIR=\"${SYS_ROOT}/%s\"\n\
PORTDIR=\"%s\"\n\
DISTDIR=\"${SYS_ROOT}/%s\"\n\
PKGDIR=\"${SYS_ROOT}/%s\"\n\
PORT_LOGDIR=\"${SYS_ROOT}/%s\"\n\
\n\
# Portage package configuration\n\
USE=\"%s\"\n\
EMERGE_DEFAULT_OPTS=\"--buildpkg --usepkg --root=\'${SYS_ROOT}\' --config-root=\'${SYS_ROOT}/autogentoo/\' --autounmask-continue\"\n\
\n\0",  conf.config.CFLAGS, conf.config.CXXFLAGS, conf.config.CHOST,
    _ROOT_,
    conf.config.PORTAGE_TMPDIR,
    conf.config.PORTDIR,
    conf.config.DISTDIR,
    conf.config.PKGDIR,
    conf.config.PORT_LOGDIR,
    conf.config.USE
    );
    
    printf (make_conf_buff);
    fflush(stdout);
    
    char *new_dirs [] = {
        conf.config.PORTDIR,
        conf.config.DISTDIR,
        conf.config.PKGDIR,
        conf.config.PORT_LOGDIR,
        "autogentoo/etc/portage"
    };
    
    int i;
    for (i=0; i!=sizeof (new_dirs) / sizeof (*new_dirs); i++) {
        char TARGET_DIR[256];
        sprintf (TARGET_DIR, "%s/%s", _ROOT_, new_dirs[i]);
        _mkdir(TARGET_DIR);
    }
    
    char make_conf_file [256];
    sprintf (make_conf_file, "%s/autogentoo/etc/portage/make.conf", _ROOT_);
    FILE * fp_mc;
    
    fp_mc = fopen (make_conf_file, "w+");
    if (fp_mc != NULL)
    {
        fputs(make_conf_buff, fp_mc);
        fclose(fp_mc);
    }
    
    // Create the profile symlink
    char sym_buf_p1 [128];
    char sym_buf_p2 [128];
    sprintf (sym_buf_p1, "/usr/portage/profiles/%s/", conf.profile);
    sprintf (sym_buf_p2, "%s/autogentoo/etc/portage/make.profile", _ROOT_);
    if (symlink (sym_buf_p1, sym_buf_p2) != 0) {
        printf ("Failed to symlink profile!\n");
    }
}

struct serve_client_manager * init_manager (char * top_dir) {
    struct serve_client_manager * out = malloc (sizeof (struct serve_client_manager));
    out->top_dir = top_dir;
    out->size = 5;
    out->used = 0;
    out->clients = malloc (sizeof(struct serve_client*) * 5);
    return out;
}

void _mkdir(const char *dir) {
        char tmp[256];
        char *p = NULL;
        size_t len;

        snprintf(tmp, sizeof(tmp),"%s",dir);
        len = strlen(tmp);
        if(tmp[len - 1] == '/')
                tmp[len - 1] = 0;
        for(p = tmp + 1; *p; p++)
                if(*p == '/') {
                        *p = 0;
                        mkdir(tmp, S_IRWXU);
                        *p = '/';
                }
        mkdir(tmp, S_IRWXU);
}
